## Начальный урок по Webcodesk

### Вступление

Зачем вам нужен Webcodesk?

* В Webcodesk вы сможете создавать Web приложения на React без написания лишнего кода для Redux (actions, reducers, selectors, и т.п.). 

* Разрабатывать каждый React компонент в изоляции от всех других компонентов по аналогии с React Storybook.

* Создавать страницы приложения комбинируя React компоненты в визуальном редакторе страниц.

* Создавать диаграммы потоков данных между страницами, компонентами и логикой приложения. 

* Легко ориентироваться, быстро менять и экспериментировать с тем, как должны протекать данные в приложении.

* Записывать и наблюдать как протекают данные на диаграммах во время реальной работы приложения.

### Создание проекта

В этом уроке мы пройдемся по всем основным особенностям Webcodesk.

Для начала нам необходимо создать новый проект. В Webcodesk мы можем создавать два типами проектов:
* c исходным кодом на JavaScript
* c исходным кодом на TypeScript

Если вы знакомы с инструментом Create React App, тогда стоит сказать, что создание проекта в Webcodesk делается с помощью Create React App.

На данный момент нам не важно какой тип проекта выбрать. Поэтому создадим проект для JavaScript - нажмите на кнопку с соответствующей надписью “New JavaScript Project”.

<img src="./img/pic1.png?raw=true" />

На экране должна появится форма ввода названия проекта и каталога в котором будет создан непосредственно проект.

Введите `hello_app` в качестве названия проекта в поле ввода `Project Name`, и выберите подходящий каталог для проекта нажав на иконку папки во втором поле ввода.

<img src="./img/pic2.png?raw=true" />

После нажатия на кнопку `Create` вы увидите на экране консольный вывод процесса создания проекта и установки npm-модулей. Строки полностью соответствуют выводу записей на консоль во время создания проекта с помощью Create React App.

Когда процесс копирования исходного кода и установка npm-модулей завершатся, на экране откроется вновь созданный проект.

<img src="./img/pic3.png?raw=true" />

В процессе инициализации проекта Webcodesk запускает Webpack Dev Server, так же как это делается в Create React App при запуске сервера командой `yarn start` после создания проекта.

Давайте убедимся, что сервер успешно запущен. Кликните на кнопку `Server Status`, и дождитесь когда в окне появится запись о том, что сервер успешно запустился.

> ***Подсказка***: по умолчанию сервер запускается на порту 3030. Но вы можете изменить значение порта в окне `Server Status`. Там же вы можете перезапустить сервер если возникнет такая необходимость.

<img src="./img/pic4.png?raw=true" />

Закройте окно `Server Status` кликнув на кнопку `Close` вверху.

После создания проекта в исходном коде будет созданно несколько компонентов. Это сделано с целью пройти данный урок без написания дополнительного кода.

Поэтому, сейчас мы создадим Single Page приложение из тех компонентов, исходный код которых был сгенерирован при создании проекта.

### Главная страница

Сначала необходимо создать главную страницу нашего приложения. По-умолчанию в проекте уже создана пустая страница с именем `main` и находится она в разделе `Pages` в левой панели рабочей области.

> ***Подсказка***: Если вы не находите имени `main` в левой панели, то вам не обходимо ее создать. Для этого нажмите иконку с плюсом в разделе `Pages` и в появившемся диалоге введите в качестве названия страницы строку "main". 

Название страницы в данном случае очень важно - это потому что Webcodesk распознает имя `main` как индексную или начальную страницу приложения.

<img src="./img/pic5.png?raw=true" />

Сделайте двойной клик на названии страницы в левой панели. Перед вами должна появится вкладка с названием страницы (или если вы создавали страницу у вас уже должна быть открыта вкладка). Это рабочая область редактора страницы.

> ***Подсказка***: если вы не увидели внутри вкладки область обведенную пунктиром и надписью "Drag and drop here", тогда нажмите на иконку `Reload` (Reload the entire page), которая находится в верхней панели инструментов.

<img src="./img/pic6.png?raw=true" />

Теперь мы можем перейти к добавлению компонентов на страницу. Откройте папку `greeting` в разделе `Components` на левой панели и с помощью мыши перетащите название `FormContainer` на область `Drag and drop here` и отпустите его там.

<img src="./img/pic7.png?raw=true" />

Последовательно перетащите компоненты `Form` и `TitlePanel` на области `form` и `title` соответственно.

<img src="./img/pic8.png?raw=true" />

Когда все компоненты будут установлены на странице кликните на кнопку `Save` на панели инструментов вверху. После этого все изменения будут записаны и Webpack сможет скомпилировать страницу с новыми инстансами компонентов. И вы теперь можете посмотреть как страница функционирует в браузере.

Для просмотра страницы необходимо кликнуть на кнопку `Live Preview` вверху на левой панели. Откроется еще одна вкладка `Live Preview` с готовой страницей `main`. 

<img src="./img/pic9.png?raw=true" />

### Первая диаграмма

Вы можете заметить, что при нажатии на кнопку `Click` на странице ничего не происходит. Давайте оживим станицу добавив в проект диаграммы, в которых укажем как должны взаимодействовать компоненты.

Воспользуйтесь уже готовой диаграммой `start`, которая была создана при создании приложения - просто двойной клик для открытия диаграммы.

> ***Подсказка***: если вы не нашли название `start` в левой панели, тогда кликните на иконку с плюсом в разделе `Flows` на левой панели и задайте имя диаграммы как "start". 

Вы увидите новую вкладку в которой будет находится диаграмма `start`.

<img src="./img/pic10.png?raw=true" />

Как вы видите на диаграмме находится прямоугольник с названием `Application`. Это элемент схемы и он является начальной точкой для потока данных в данной конкретной диаграмме.

Элемент `Application` имеет единственное событие `onAplicationStart`, которое срабатывает в начале запуска приложения в браузере.


Давайте сделаем так, чтобы при запуске приложения на странице высвечивалось приветствие для пользователя.

Для этого откройте папку `greeting` в разделе `Functions`  на левой панели, а затем откройте список доступных функций кликнув на иконку группы функций `api` в открывшейся папке.

> ***Подсказка***: По-молчанию в ходе создания проекта был сгенерирован код пары функций, в которых находится необходимая логика для нашего урока. Функции - это простые JS функции, но они имеют определенную сигнатуру для того, чтобы Webcodesk мог понять как их применить. Об этом мы поговорим позднее, когда будем рассматривать исходный код компонентов и функций.

Теперь найдите в списке функций название `initialTitle` и перетащите его с помощью мыши на пунктирную область которая находится за элементом `Application` и соединена с ним пунктирной линией.

<img src="./img/pic11.png?raw=true" />

Компилятор сразу же укажет, что есть ошибка на диаграмме, отметив это красным индикатором на элементе в верхнем правом углу. 

> ***Подсказка***: Кликнув на индикатор вы увидите всплывающее сообщение с текстом ошибки.

На данный момент Webcodesk предупреждает, что элемент на диаграмме не соединен ни с одним другим элементом и поэтому не будет участвовать в передаче данных.

<img src="./img/pic12.png?raw=true" />

Соединить элементы можно с помощью мыши. Наведите мышкой на точку выхода события `onApplicationStart` элемента `Application`, нажмите кнопку мыши и удерживая ее в нажатом состоянии потяните курсор на точку входа `callFunction` элемента `initialTitle` и отпустите кнопку мыши.

> ***Подсказка***: если элементы слишком маленькие на экране, вы можете с помощью прокрутки колеса мыши отрегулировать масштаб диаграммы. A для перемещения диаграммы просто нажмите кнопку мыши на любой незанятой области и удерживая ее переместите курсор в нужном направлении.

<img src="./img/pic13.png?raw=true" />

Таким образом мы сделали так, что при запуске приложения будет вызвана функция с названием `initialTitle`. И поэтому компилятор уберет индикатор ошибки.

Как видите функция `initialTitle` на диаграмме имеет событие `title`. Это событие сработает в ходе выполнения логики функции. Код функции мы рассмотрим позднее, а сейчас просто запомним, что данная функция выдает строку приветствия на выходе события `title`.

Чтобы посмотреть описание функций входящих в набор сделайте двойной клик на названии функции или набора функций на левой панели. В открывшейся вкладке будет описание функций.

<img src="./img/pic14.png?raw=true" />

Чтобы показать приветствие на главной странице приложения, нам необходимо в диаграмму добавить компонент в который будет передана строка приветствия при запуске приложения.

Таким компонентом является компонент `TitlePanel`. Но нам необходим не абстрактный компонент, а именно инстанс компонента, который мы добавляли на главную страницу.

Поэтому давайте откроем содержание страницы в разделе `Pages` на левой панели. Кликните на иконку страницы `main` и найдите внутри название `titlePanel`. Это название инстанса компонента класса `TitlePanel`, который мы вставили на этапе создания страницы.

> ***Подсказка***: можно использовать разные названия инстансов одного и того-же компонента. Для этого нужно их переименовывать в редакторе страниц - воспользуйтесь кнопкой `Rename` на панели инструментов редактора страниц.

Теперь просто перетащите название на диаграмму в пустой прямоугольник соединенный с элементом `initialTitle` пунктирной линией.

Затем соедините выход `title` элемента `initialTitle` с входом `title` свойства на элементе `titlePanel` как это показано на рисунке ниже.

<img src="./img/pic15.png?raw=true" />

Если вы снова откроете вкладку `Live Preview`, то вы увидите, что заголовок над полем ввода поменялся на строку приветствия.

<img src="./img/pic16.png?raw=true" />

Это означает, что при запуске приложения свойство инстанса `titlePanel` компонента `TitlePanel` на странице получило значение строки из события `title` функции `initialTitle` - так как мы и указали в диаграмме.

### Вторая диаграмма

Теперь давайте добавим интерактивности в нашу форму ввода.

Создайте новую диаграмму с названием `show_greeting` - тут мы опишем случай когда напечатанный пользователем текст в поле ввода будет обработан другой функцией и результат будет выведет на заголовок.

> ***Подсказка***: старайтесь создавать диаграммы подобно тому как пишутся use cases. Даже если вам необходимо реализовать несколько почти одинаковых сценариев с одинаковыми элементами. Это не будет оверхедом, потому что в ходе компиляции проекта Webcodesk-ом все диаграммы консолидируются в одну большую и повторений вызовов событий или функций не будет. Зато вам будет легко ориентироваться и рефакторить диаграммы в соответствии с изменениям в use cases потом.

Найдите в содержимом страницы `main` инстанс `form` на левой панели и перетащите его в пустой прямоугольник, который находится ___под___ элементом `Application` на новой диаграмме.

Таким образом мы заменяем `Application` элемент на `form` элемент, и начальная точка потока данных в диаграмме будет теперь сама форма, а не старт приложения.

<img src="./img/pic17.png?raw=true" />

Последовательно добавьте в схему и соедините один за другим элементы функции `greeting` и инстанса `titlePanel`, как это показано на рисунке ниже.

<img src="./img/pic18.png?raw=true" />

Откройте `Live Preview` и попробуйте написать какое-то имя в поле ввода, а затем кликните на кнопку `Click`. Заголовок поменяется соответственно тому, что вы ввели.

Таким образом мы построили приложение с формой на главной странице, на которой пользователь может ввести свое имя и приложение его поприветствует.

<img src="./img/pic19.png?raw=true" />

### Роутинг

На данный момент наше приложение имеет всего одну страницу. Для того чтобы ознакомиться с тем как можно в Webcodesk организовать переходы между страницами, давайте добавим еще одну страницу.

Но перед этим необходимо усвоить одно правило. Вы можете называть страницы как вам угодно, но есть два специальных названия - это `main` и `noMatch`.

`main` страница, как вы уже знаете, устанавливается как домашняя или главная страница приложения. `noMatch` страница - это страница, на которую будет перенаправлен пользователь если он введет несуществующий путь в адресную строку.

Если же в проекте не существует страницы `noMatch`, тогда перенаправление несуществующих адресов будет производится на главную страницу.

Давайте создадим страницу `noMatch` чтобы убедится как это работает. Создайте страницу и перетащите туда компонент `NoMatchTitlePanel`  из раздела `Components` на левой панели.

> ***Подсказка***: для комбинирования компонентов на странице вы также можете использовать дополнительную панель отображающую структуру страницы. Для этого нажмите кнопку `Structure` на панели инструментов в редакторе страницы. Это очень полезно когда вы вставляете невидимые компоненты в страницу.

<img src="./img/pic20.png?raw=true" />

А сейчас нам необходимо создать новую диаграмму, где мы отобразим случай когда пользователь попал на данную страницу и хочет из нее выйти кликнув на `Back Home` кнопку на странице.

Создайте новую диаграмму `back_home` и замените элемент `Application` на инстанс компонента `noMatchTitlePanel` расположенный на странице `noMatch`. Для этого просто перетяните имя `noMatchTitlePanel` из раздела `Pages` в левой панели на пустой прямоугольник ___под___ элементом `Application` на диаграмме.

Теперь перетяните название страницы `main` из левой панели в пустой прямоугольник связанный с элементом `noMatchTitlePanel`, и соедините выход `onBackHome` c входом `forward`.

В результате у вас должна выйти диаграмма показанная на рисунке ниже.

<img src="./img/pic21.png?raw=true" />

Для того чтобы проверить или это работает зайдите в `Live Preview`, кликните на кнопку `Pages` на панели инструментов. Там вы увидите список доступных страниц. Кликните на пункт `noMatch` в этом списке и вы перейдете на страницу `noMatch`.

Либо, для проверки того, как работает перенаправление на `noMatch` страницу, напечатайте какой-нибудь несуществующий адрес в адресной строке на панели инструментов вверху страницы в `Live Preview` и нажмите `Enter` на клавиатуре. 

<img src="./img/pic22.png?raw=true" />

Теперь, если вы кликните на кнопку `Back Home` на странице, вы будете перенаправлены на главную страницу.

Также вы можете проверить работу приложения в браузере - просто кликните на иконку `открыть во внешнем браузере` на панели инструментов вверху `Live Preview`.

<img src="./img/pic23.png?raw=true" />

### Исходный код

После того как вы убедились в работоспособности приложения, настало время разобраться в исходном коде компонентов и функций.

Весь исходный код приложения находится в каталоге с именем, который вы указывали при создании проекта. Давайте сначала рассмотрим структуру проекта.

Если вы зайдете в каталог проекта, то вы увидите стандартную структуру каталогов, которую создает Create React App:

```
public/
src/
package.json
...
```

Но если открыть каталог `src`, то мы увидим внутри немного другую структуру каталогов и файлов, чем та, которую создает Create React App:

```
app/
etc/
usr/
index.css
index.js
serviceWorker.js
```

Где:
* `app` - сервисный каталог, в него записываются файлы которые генерирует Webcodesk для работы приложения - индексные файлы компонентов и функций, конфигурационные файлы для [Reac App Framework](https://github.com/webcodesk/react-app-framework), файлы страниц и роутера;
* `etc` - сервисный каталог, в него Webcodesk сохраняет файлы диаграмм и страниц;
* `usr` - каталог в котором находятся исходные файлы компонентов, функций и всей логики приложения, которую пишет разработчик;

Содержимое `app` каталога не представляет интереса для разработчика потому что содержимое генерируется полностью Webcodesk-ом на основе конфигурационных файлов в `etc` каталоге.

В каталоге `etc` находятся исходные файлы для страниц и диаграмм в Webcodesk. Работа проделанная нами в Webcodesk в ходе этого урока хранится именно там. Поэтому `etc` каталог обязательно необходимо включать в систему контроля версий.

А вот весь исходный код, который пишется непосредственно самим разработчиком находится в каталоге `usr`. Поэтому мы должны зайти туда и просмотреть находящиеся там файлы чтобы понять как сделаны компоненты и функции которые мы использовали на диаграммах и страницах.

#### Компонент FormContainer

Так как мы начинали урок с создания страницы, на которую поместили первым компонент `FormContainer`, давайте рассмотрим код этого компонента.

Откройте в любимом редакторе `src/usr/greeting/FormContainer.js` файл.

```javascript

import React from 'react';
import PropTypes from 'prop-types';
import { Placeholder } from "./Commons";

const rootStyle = {
  height: '450px',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
  width: '100%',
  overflow: 'auto',
};

const cellStyle = {
  padding: '5px 0'
};

/*
  Component holds a single form and a title
 */
const FormContainer = ({form, title}) => {
    return (
      <div style={rootStyle}>
        <div style={cellStyle}>
          {title}
        </div>
        <div style={cellStyle}>
          {form}
        </div>
      </div>
    );
};

FormContainer.propTypes = {
  // form element position
  form: PropTypes.element,
  // title element position
  title: PropTypes.element,
};

FormContainer.defaultProps = {
  form: <Placeholder name="form" />,
  title: <Placeholder name="title" />,
};

export default FormContainer;

```

**Как вы видите `FormContainer` - это функциональный компонент с названием полностью совпадающим с названием файла, и экспортируется он по умолчанию. Это есть первое условие того чтобы Webcodesk распознал в этом файле компонент и включил его в список доступных компонентов на левой панели в разделе `Components`.**

Также нас интересует почему при появлении в редакторе страниц компонент имеет еще два поля, в которые можно вставить другие компоненты.

Причиной этого является то, что в коде компонента есть определение свойств `form` и `title` с помощью PropTypes. И при этом тип этих свойств это `PropTypes.element`.

```javascript
FormContainer.propTypes = {
  // form element position
  form: PropTypes.element,
  // title element position
  title: PropTypes.element,
};
```

Данное объявление показывает Webcodesk, что этот компонент принимает другие компоненты в виде свойств. Поэтому в редакторе страницы мы видели пустые области когда данные свойства были пустыми. И мы могли туда переместить другие компоненты.

Эти же области вы найдете на отображении структуры страницы.

<img src="./img/pic24.png?raw=true" />

#### Компонент TitlePanel

Следующий код, который мы рассмотрим, это код компонента `TitlePanel` в файле `src/usr/greeting/TitlePanel.js`.

```javascript
import React from 'react';
import PropTypes from 'prop-types';
/*
  Panel with title
 */
class TitlePanel extends React.Component {
  static propTypes = {
    // simple title text
    title: PropTypes.string,
  };

  render () {
    const { title } = this.props;
    return (
      <h1 style={{ textAlign: 'center' }}>
        {title || 'Empty Title'}
      </h1>
    );
  }
}

export default TitlePanel;
```

**Второе правило объявления компонентов - это класс наследуемый от React.Component с названием полностью совпадающим с названием файла, и экспортом этого класса по умолчанию.**

В этом компоненте также объявлено свойство с помощью PropTypes для того, чтобы Webcodesk мог использовать его как точку входа на диаграммах. Свойство имеет тип `PropTypes.string`.

#### Компонент Form

Для того чтобы увидеть как отображаются свойства событий на диаграмме, рассмотрим код компонента Form в файле `src/usr/greeting/Form.js`.

```javascript
import React from 'react';
import PropTypes from 'prop-types';

const rootStyle = {
  width: '150px',
  height: '150px',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
};

const inputStyle = {
  padding: '5px',
  borderRadius: '4px',
  border: '1px solid #cccccc',
};

const buttonStyle = {
  padding: '5px',
  borderRadius: '4px',
};

/*
  Input form for the user name
 */
class Form extends React.Component {
  static propTypes = {
    // send the entered name
    onClick: PropTypes.func,
  };
  
  static defaultProps = {
    onClick: () => {
      // is not set
    },
  };

  handleClick = (e) => {
    if (e) {
      e.stopPropagation();
      e.preventDefault();
    }
    this.props.onClick(this.inputElement.value);
  };

  render () {
    return (
      <form onSubmit={this.handleClick}>
        <div style={rootStyle}>
          <div style={{ margin: '1em 0 1em 0' }}>
            <input
              ref={me => this.inputElement = me}
              type="text"
              placeholder="Enter your name"
              style={inputStyle}
            />
          </div>
          <div>
            <button
              type="submit"
              onClick={this.handleClick}
              style={buttonStyle}
            >
              Click
            </button>
          </div>
        </div>
      </form>
    );
  }
}

export default Form;
```

И в данном коде можно видеть, что свойство `onClick` имеет тип `PropTypes.func`, поэтому оно будет отображаться на диаграмме справа как выход данных из элемента.

А еще можно увидеть, что метод вызывается по нажатию кнопки на форме и тогда передается строка введенная в поле ввода.

> ***Подсказка***: передача данных в диаграммах происходит только для первого аргумента метода, поэтому, если будет указан второй аргумент в методе он будет проигнорирован и не будет передан дальше по цепочке. Чтобы передавать много данных инкапсулируйте их в объект и передавайте его в первом аргументе метода: ` this.props.onClick({data1, data2}); `

#### Итог по компонентам

Давайте суммируем то, что мы увидели в коде.

Очевидно, что для того, чтобы ваш компонент мог включать в себя другие компоненты на странице, необходимо в классе или функции компонента объявить свойства с типом `PropTypes.element`.

Чтобы компонент мог отдавать данные по какому-то событию на диаграмме, необходимо добавить в него свойство типа `PropTypes.func`.

А для того, чтобы компонент мог быть получателем данных на диаграмме, необходимо добавить в него свойства любого типа кроме `PropTypes.element` и `PropTypes.func`.

#### Functions

Теперь давайте рассмотрим устройство функций. Откройте `src/usr/greeting/api.js` файл.

```javascript
/*
 Produce the initial title value

 No parameters.

 Dispatching:

 * **title** - an initial title text

 */
export const initialTitle = () => (dispatch) => {
  dispatch('title', 'Welcome! What is your name?');
};

/*
 Provide a greeting to the user

 Parameters:
 * **who** - value is used in the `greeting` string

 Dispatching:
 * **greeting** - greeting text with `who` input argument
 */
export const greetings = (who) => (dispatch) => {
  dispatch('greeting', who ? `Hello, ${who} !!!` : 'Hello, Noname !!!');
};
```

**Минимальным и достаточным условием для объявления функции, которая может использоваться на диаграммах Webcodesk, является экспорт стрелочной функции с curring.**

Первая функция из цепочки может иметь один или не иметь вообще параметров, потому что данные при вызове функции передаются только в первом аргументе или не передаются вообще. Но вторая функция из цепочки должна иметь всегда параметр `dispatch`.
 
**В теле функции мы видим использование `dispatch`, где первый аргумент - строка. Эта строка определяет имя исходящего события в функции на диаграмме.**

> ***Подсказка***: Вы можете размещать вызовы `dispatch` где угодно в теле функции.

В момент выполнения `dispatch`, данные, которые являются вторым аргументом в вызове `dispatch`, просто передаются в получатель, который связан на диаграмме с именем этого `dispatch`.

<img src="./img/pic25.png?raw=true" />

То есть, в случае выполнения функции `greetings`, в нее будет передана строка из `form` по событию `onClick`, после будет вызван `dispatch` с названием `greeting` который передаст новую строку в свойство `title` инстанса `titlePanel`.

> ***Подсказка***: Если необходимо передавать сложные данные, то их необходимо инкапсулировать в объект: ` dispatch('someEvent', {data1, data2}); `

> ***Подсказка***: Так как при передаче данных используется связка Redux/Reselect, то помните, что для того, чтобы данные изменились в компоненте, необходимо передать вновь созданный объект: `dispatch('someEvent', {...oldData});`

### Разработка новых компонентов и функций

Теперь вы готовы делать свои компоненты и функции, а также связывать их на диаграммах.

Вы можете вносить изменения в существующий код или добавлять новые файлы с компонентами и функциями. И вам не нужно ничего делать для того чтобы изменения были доступны в Webcodesk. Он подхватит автоматически новый код, и если код был правильно оформлен, то изменения будут отображены в проекте.

Еще одно очень полезное свойство в Webcodesk - это возможность разработки компонентов в изоляции. То есть вам не нужно создавать еще одну страницу, чтобы туда поместить компонент, который вы хотите отладить.

Для этого просто сделайте двойной клик по названию компонента в разделе `Components`. Появится новая вкладка, в которой будет отображен компонент с установленными свойствами по-умолчанию.

<img src="./img/pic26.png?raw=true" />

В просмотре компонента есть возможность прочитать описание компонента на вкладке `About`, которое было собрано на основе комментариев в исходном коде.

Если у вас есть необходимость проверить компонент с разными настройками, тогда для этого в Webcodesk можно создавать истории для компонента. Это работает по аналогии с React StoryBook.

Как пример, сделайте двойной клик на компоненте `Form`. В открывшемся окне перейдите на вкладку `Stories`, вы увидите два пункта в списке историй. Первый - это компонент с дефолтными свойствами. И второй - это кастомные настройки свойств компонента.

<img src="./img/pic27.png?raw=true" />

**Чтобы добавить свои истории для компонента достаточно создать в исходном коде рядом с файлом компонента файл с идентичным названием, но с расширением `.stories.js`.**

В файле историй необходимо сделать экспорт массива объектов с полями `story` и `renderStory`, то есть, названием истории и функцией рендера истории соответственно.

Используйте как пример файл историй компонента “Form” `src/usr/greeting/Form.stories.js`

```javascript
import React from 'react';
import Form from './Form';

export default [
  {
    story: 'With alert assigned to the on click event',
    renderStory: () => {

      const handleClick = (name) => {
        alert(`You typed name: ${name}`);
      };

      return <Form onClick={handleClick} />
    },
  }
]
```

### Отладка потока данных

Одной из очень полезных возможностей в Webcodesk является возможность записать и просмотреть какие данные были переданы по связям в диаграммах.

Это можно использовать при отладке приложения.

Откройте `Live Preview`, перейдите на главную страницу если открыта не она. Найдите кнопку `Record` на панели инструментов вверху и кликните на нее - кнопка изменит свое название на `Stop`.

<img src="./img/pic28.png?raw=true" />

Таким образом вы запустили запись данных, которые передаются по цепочкам при возникновении каких-либо событий в приложении.

Введите какое-то слово в поле ввода на главной странице и кликните на кнопку `Click`.

Далее остановите запись кликнув на `Stop`, и как-только вы остановите запись вам будет представлена сводная диаграмма компонентов и функций, которые используются в приложении.

<img src="./img/pic29.png?raw=true" />

На диаграмме будут нарисованы пунктиром элементы, которые не принимали участие в передаче данных, а те элементы, которые получали и передавали данные будут нарисованы цветами, как это делается в редакторе диаграммы.

<img src="./img/pic30.png?raw=true" />

Внизу экрана вы можете видеть записи, которые были сделаны во время действий пользователя.

Для того чтобы увидеть какие данные присутствовали в узлах диаграммы, необходимо просто кликнуть на желаемый узел и соответствующие запись или записи будут подсвечены внизу.

При клике на строку записи будут показаны непосредственно данные в виде JSON.

## React App Framework

Передача данных в созданном нами приложении происходит с помощью специально разработанного для Webcodesk фреймворка, который использует внутри Redux.

Исходный код и описание самого фреймворка можно посмотреть на GitHub здесь: [https://github.com/webcodesk/react-app-framework](https://github.com/webcodesk/react-app-framework)

Фреймворк устанавливается в виде npm-модуля и использует файлы из каталога `app` для создания контейнеров компонентов, их редюсеров и цепочек для action creators.

Также фреймворк динамически создает конфигурацию для React Router 4, который используется в приложении для перехода между страницами.

Несмотря на то, что фреймворк не вносит никаких побочных эффектов в работу приложения и полностью удовлетворяет принципам передачи данных в Redux, использование его накладывает ограничения на создание приложения с разделением кода и ленивой загрузки страниц.

Вы можете смело использовать его в сложных приложениях. Например, Webcodesk внутри использует данный фреймворк.

Но если вам необходимо использовать проверенный временем подход с Redux/Reselect/React Router, а также разделение кода и лениву загрузку страниц, то Webcodesk может выгрузить оптимизированный код для приложения. 

В сгенерированном коде не будет использоваться React App Framework, и будет реализовано разделение кода и ленивая загрузка страниц с помощью React Lazy.

Сейчас мы попробуем сделать экспорт нашего проекта в проект с оптимизированным кодом. Но перед этим создайте пустой каталог с названием `hello_app_exported` - в него мы будем экспортировать код.

Теперь откройте `Live Preview` и кликните на кнопку `Export`. В появившемся диалоге выберите пустой каталог, который вы создали перед этим.

<img src="./img/pic31.png?raw=true" />

Кликайте на кнопку “Export”. 

После сообщения о том, что код успешно экспортирован, заходите в заданный каталог. 

В каталоге будет такая же структура файлов и папок как и в нашем начальном проекте, но внутри `src` будет отсутствовать `etc` каталог и в `app` будет код который сгенерирован Webcodesk с учетом оптимизации и без использования React App Framework.

Далее вы можете запустить команду на сборку приложения: `yarn build` и деплоить готовое приложение из каталога `build`, как это указано в документации Create React App

Если вы вносили какие-то изменения в исходный проект после экспорта, вы всегда сможете снова сделать экспорт кода в тот же каталог.

## Возможные проблемы

#### Пустая страница

Возможны сбои при загрузке страниц где отображаются компоненты и страницы. Для устранения этого - просто нажмите на `Reload` иконку на каждой такой странице

#### Сервер не запускается

Кроме случая с занятыми портами, который рещается изменением номера порта в `Server Status`, вы можете столкнуться с ошибкой `ENOENT`. Эта ошибка показывает, что путь к исполняемому файлу NodeJS не доступен в переменной `PATH`.

