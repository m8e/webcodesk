## Начальный урок по Webcodesk

### Вступление

Зачем вам нужен Webcodesk?

* В Webcodesk вы сможете создавать Web приложения на React без написания лишнего кода для Redux (actions, reducers, selectors, и т.п.) и React Router. 

* Разрабатывать каждый React компонент в изоляции от всех других компонентов по аналогии с React Storybook.

* Создавать страницы приложения комбинируя React компоненты в визуальном редакторе страниц.

* Создавать диаграммы потоков данных между страницами, компонентами и логикой приложения. 

* Легко ориентироваться, быстро менять и экспериментировать с тем, как должны протекать данные в приложении.

* Записывать и наблюдать как протекают данные на диаграммах во время реальной работы приложения.

### Создание проекта

В этом уроке мы пройдемся по всем основным особенностям Webcodesk.

Для начала нам необходимо создать новый проект. В Webcodesk мы можем создавать два типами проектов:
* c исходным кодом на JavaScript
* c исходным кодом на TypeScript

Если вы знакомы с инструментом Create React App, тогда стоит сказать, что создание проекта в Webcodesk делается с помощью Create React App.

На данный момент нам не важно какой тип проекта выбрать. Поэтому создадим проект для JavaScript - нажмите на кнопку с соответствующей надписью “New JavaScript Project”.

***{IMAGE}***

На экране должна появится форма ввода названия проекта и каталога в котором будет создан непосредственно проект.

Введите `hello_app` в качестве названия проекта в поле ввода `Project Name`, и выберите подходящий каталог для проекта нажав на иконку папки во втором поле ввода.

***{IMAGE}***

После нажатия на кнопку `Create` вы увидите на экране консольный вывод процесса создания проекта и установки npm-модулей. Строки полностью соответствуют выводу записей на консоль во время создания проекта с помощью Create React App.

Когда процесс копирования исходного кода и установка npm-модулей завершатся, на экране откроется вновь созданный проект.

***{IMAGE}***

В процессе инициализации проекта Webcodesk запускает Webpack Dev Server, так же как это делается в Create React App при запуске сервера командой `yarn start` после создания проекта.

Давайте убедимся, что сервер успешно запущен. Кликните на кнопку `Server Status`, и дождитесь когда в окне появится запись о том, что сервер успешно запустился.

> ***Подсказка***: по умолчанию сервер запускается на порту 3030. Но вы можете изменить значение порта в окне `Server Status`. Там же вы можете перезапустить сервер если возникнет такая необходимость.

***{IMAGE}***

Закройте окно `Server Status` кликнув на кнопку `Close` вверху.

После создания проекта в исходном коде будет созданно несколько компонентов. Это сделано с целью пройти данный урок без написания дополнительного кода.

Поэтому, сейчас мы создадим Single Page приложение из тех компонентов, исходный код которых был сгенерирован при создании проекта.

### Главная страница

Сначала необходимо создать главную страницу нашего приложения. По-умолчанию в проекте уже создана пустая страница с именем `main` и находится она в разделе `Pages` в левой панели рабочей области.

> ***Подсказка***: Если вы не находите имени `main` в левой панели, то вам не обходиомо ее создать. Для этого нажмите иконку с плюсом в разделе `Pages` и в появившемся диалоге введите в качестве названия страницы строку "main". 

Название страницы в данном случае очень важно потому, что Webcodesk распознает имя `main` как индексную или начальную страницу приложения.

***{IMAGE}***

Сделайте двойной клик на названии страницы в левой панели. Перед вами должна появится закладка с названием страницы (или если вы создавали страницу у вас уже должна быть открыта закладка). Это рабочая область редактора страницы.

> ***Подсказка***: если вы не увидели внутри закладки область обведенную пунктиром и надписью "Drag and drop here", тогда нажмите на иконку `Reload` (Reload the entire page), которая находится в верхней панели инструментов.

***{IMAGE}***

Теперь мы можем перейти к добавлению компонентов на страницу. Откройте папку `greeting` в разделе `Components` на левой панели и с помощью мыши перетащите название `FormContainer` на область `Drag and drop here` и отпустите его там.

***{IMAGE}***

Последовательно перетащите компоненты `Form` и `TitlePanel` на области `form` и `title` соответственно.

***{IMAGE}***

Когда все компоненты будут установлены на странице кликните на кнопку `Save` на панель инструментов вверху. После этого все изменения будут записаны и Webpack сможет скомпилировать страницу с новыми инстансами компонентов. А вы теперь можете посмотреть как страница функционирует в браузере.

Для просмотра страницы необходимо кликнуть на кнопку `Live Preview` вверху на левой панели. Откроется еще одна закладка `Live Preview` с готовой страницей `main`. 

***{IMAGE}***

### Первая диаграмма

Вы можете заметить, что при нажатии на кнопку “Click” на странице ни к чему не приводит. Давайте оживим станицу добавив в проект диаграммы, в которых укажем как должны взаимодействовать компоненты.

Воспользуйтесь уже готовой диаграммой `start`, которая была создана при создании приложения - просто двойной клик для открытия диаграммы.

> ***Подсказка***: если вы не нашли название `start` в левой панели, тогда кликните на иконку с плюсом в разделе `Flows` на левой панели и задайте имя диаграммы как "start". 

Вы увидите новую вкладку в которой будет находится новая диаграмма.

***{IMAGE}***

Как вы видите на диаграмме находится прямоугольник в названием `Application`. Это элемент схемы и он является начальной точкой для потока данных в данной конкретной диаграмме.

Элемент `Application` имеет единственное событие `onAplicationStart`, которое срабатывает в начале запуска приложения в браузере.


Давайте сделаем так, чтобы при запуске приложения на странице высвечивалось приветствие для пользователя.

Для этого откройте папку `greeting` в разделе `Functions`  на левой панели, а затем откройте список доступных функций кликнув на иконку группы функций `api` в открывшейся папке.

> ***Подсказка***: По-молчанию в ходе создания проекта был сгенерирован код парочки функций, в которых находится необходимая логика для нашего урока. Функции - это простые JS функции, но они имеют определенную сигнатуру для того, чтобы Webcodesk мог понять как их применить. Об этом мы поговорим позднее, когда будем рассматривать исходный код компонентов и функций.

Теперь найдите в списке функций название `initialTitle` и перетащите его с помощью мыши на пунктирную область которая находится за элементом `Application` и соединена с ним пунктирной линией.

***{IMAGE}***

Компилятор сразу же укажет, что есть ошибка на диаграмме, отметив это красным индикатором на элементе в верхнем правом углу. 

> ***Подсказка***: Кликнув на индикатор вы увидите всплывающее сообщение с текстом ошибки.

На данный момент Webcodesk предупреждает, что элемент на диаграмме не соединен ни с одним другим элементом и поэтому не будет участвовать в передаче данных.

***{IMAGE}***

Соединить элементы можно с помощью мыши. Наведите мышкой на точку выхода события `onApplicationStart` элемента `Application`, нажмите кнопку мыши и удерживая ее в нажатом состоянии потяните курсор на точку входа `callFunction` элемента `initialTitle` и отпустите кнопку мыши.

> ***Подсказка***: если элементы слишком маленькие на экране, вы можете с помощью прокрутки колеса мыши отрегулировать масштаб диаграммы. A для перемещения диаграммы просто нажмите кнопку мыши на любой незанятой области и удерживая ее переместите курсор в нужном направлении.

***{IMAGE}***

Таким образом мы сделали так, что при запуске приложения будет вызвана функция с названием `initialTitle`. И поэтому компилятор уберет индикатор ошибки.

***{IMAGE}***

Как видите функция `initialTitle` на диаграмме имеет событие `title`. Это событие сработает в ходе выполнения логики функции. Код функции мы рассмотрим позднее, а сейчас просто запомним, что данная функция выдает строку приветствия на выходе события `title`.

Чтобы посмотреть описание функций входящих в набор сделайте двойной клик на названии функции или набора функций на левой панели. В открывшейся вкладке будет описание функций.

***{IMAGE}***

Чтобы показать приветствие на главной странице приложения, нам необходимо в диаграмму добавить компонент в который будет передана строка приветствия при запуске приложения.

Таким компонентом является компонент `TitlePanel`. Но нам необходим не абстрактный компонент, а именно инстанс компонента, который мы добавляли на главную страницу.

Поэтому давайте откроем содержание страницы в разделе `Pages` на левой панели. Кликните на иконку страницы `main` и найдите внутри название `titlePanel`. Это название инстанса компонента класса `TitlePanel`, который мы вставили на этапе создания страницы.

> ***Подсказка***: можно использовать разные названия инстансов одного и того-же компонента. Для этого нужно их переименовывать в редакторе страниц - воспользуйтесь кнопкой `Rename` на панели инструментов редактора страниц.

Теперь просто перетащите название на диаграмму в пустой прямоугольник соединенный с элементом `initialTitle` пунктирной линией.

Затем соедините выход `title` элемента `initialTitle` с входом `title` свойства на элементе `titlePanel` как это показано на рисунке ниже.

***{IMAGE}***


Если вы снова откроете вкладку `Live Preview`, то вы увидите, что заголовок над полем ввода поменялся на строку приветствия.

***{IMAGE}***

Это означает, что при запуске приложения свойство инстанса `titlePanel` компонента `TitlePanel` на странице получило значение строки из события `title` функции `initialTitle` - так как мы и указали в диаграмме.

### Вторая диаграмма

Теперь давайте добавим интерактивности в нашу форму ввода.

Создайте новую диаграмму с названием `show_greeting` - тут мы опишем случай когда напечатанный пользователем текст в поле ввода будет обработан другой функцией и результат будет выведет на заголовок.

> ***Подсказка***: старайтесь создавать диаграммы подобно тому как пишутся use cases. Даже если вам необходимо реализовать несколько почти одинаковых сценарием с одинаковыми элементами. Это не будет оверхедом, потому что в ходе компиляции проекта Webcodesk-ом все диаграммы консолидируются в одну большую и повторений вызовов событий или функций не будет. Зато вам будет легко ориентироваться и рефакторить диаграммы в соответствии с изменениям в use cases потом.

Найдите в содержимом страницы `main` инстанс `form` на левой панели и перетащите его в пустой прямоугольник, который находится ___под___ элементом `Application` на новой диаграмме.

Таким образом мы заменяем `Application` элемент на `form` элемент, и начальная точка потока данных в диаграмме будет теперь сама форма, а не старт приложения.

***{IMAGE}***

Последовательно добавьте в схему и соедините один за другим элементы функции `greeting` и инстанса `titlePanel`, как это показано на рисунке ниже.

***{IMAGE}***

Откройте `Live Preview` и попробуйте написать какое-то имя в поле ввода, а затем кликните на кнопку `Click`. Заголовок поменяется соответственно тому, что вы ввели.

Таким образом мы построили приложение с формой на главной странице, на которой пользователь может ввести свое имя и приложение его поприветствует.

***{IMAGE}***

### Роутинг

На данный момент наше приложение имеет всего одну страницу. Для того чтобы ознакомиться с тем как можно в Webcodesk организовать переходы между страницами, давайте добавим еще одну страницу.

Но перед этим необходимо усвоить одно правило. Вы можете называть страницы как вам угодно, но есть два специальных названия - это `main` и `noMatch`.

`main` страница, как вы уже знаете, устанавливается как домашняя или главная страница приложения. `noMatch` страница - это страница, на которую будет перенаправлен пользователь если он введет несуществующий путь в адресную строку.

Если же в проекте не существует страницы `noMatch`, тогда перенаправление несуществующих адресов будет производится на главную страницу.

Давайте создадим страницу `noMatch` чтобы убедится как это работает. Создайте страницу и перетащите туда компонент `NoMatchTitlePanel`  из раздела `Components` на левой панели.

> ***Подсказка***: для комбинирования компонентов на странице вы также можете использовать дополнительную панель отображающую структуру страницы. Для этого нажмите кнопку `Structure` на панели инструментов в редакторе страницы. Это очень полезно когда вы вставляете невидимые компоненты в страницу.

***{IMAGE}***

А сейчас нам необходимо создать новую диаграмму, где мы отобразим случай когда пользователь попал на данную страницу и хочет из нее выйти кликнув на `Back Home` кнопку на странице.

Создайте новую диаграмму `back_home` и замените элемент `Application` на инстанс компонента `noMatchTitlePanel` расположенный на странице `noMatch`. Для этого просто перетяните имя `noMatchTitlePanel` из раздела “Pages” в левой панели на пустой прямоугольник ___под___ элементом `Application` на диаграмме.

Теперь перетяните название страницы `main` из левой панели в пустой прямоугольник связанный с элементом `noMatchTitlePanel`, и соедините выход `onBackHome` c входом `forward`.

В результате у вас должна выйти диаграмма показанная на рисунке ниже.

***{IMAGE}***

Для того чтобы проверить или это работает зайдите в `Live Preview`, кликните на кнопку `Pages` на панели инструментов. Там вы увидите список доступных страниц. Кликните на пункт `noMatch` в этом списке и вы перейдете на страницу `noMatch`.

Либо, для проверки того, как работает перенаправление на `noMatch` страницу, напечатайте какой-нибудь несуществующий адрес в адресной строке на панели инструментов вверху страницы в `Live Preview` и нажмите `Enter` на клавиатуре. 

***{IMAGE}***

Теперь, если вы кликните на кнопку `Back Home` на странице, вы будете перенаправлены на главную страницу.

Также вы можете проверить работу приложения в браузере - просто кликните на иконку `открыть во внешнем браузере` на панели инструментов вверху `Live Preview`.

***{IMAGE}***

### Исходный код

После того как вы убедились в работоспособности приложения, настало время разобраться в исходном коде компонентов и функций.

Весь исходный код приложения находится в каталоге с именем, который вы указывали при создании проекта. Давайте сначала рассмотрим структуру проекта.

Если вы зайдете в каталог проекта, то вы увидите стандартную структуру каталогов, которую создает Create React App:

```
public/
src/
package.json
...
```

Но если открыть каталог `src`, то мы увидим внутри немного другую структуру каталогов и файлов, чем та, которую создает Create React App:

```
app/
etc/
usr/
index.css
index.js
serviceWorker.js
```

Где:
* `app` - сервисный каталог, в него записываются файлы которые генерирует Webcodesk для работы приложения - индексные файлы компонентов и функций, конфигурационные файлы для [Reac App Framework](https://github.com/webcodesk/react-app-framework), файлы страниц и роутера;
* `etc` - сервисный каталог, в него Webcodesk сохраняет файлы диаграмм и страниц;
* `usr` - каталог в котором находятся исходные файлы компонентов, функций и всей логики приложения, которую пишет разработчик;

Содержимое `app` каталога не представляет интереса для разработчика потому что содержимое генерируется полностью Webcodesk-ом на основе конфигурационных файлов в `etc` каталоге.

В каталоге `etc` находятся исходные файлы для страниц и диаграмм в Webcodesk. Работа проделанная нами в Webcodesk в ходе этого урока хранится именно там. Поэтому `etc` каталог обязательно необходимо включать в систему контроля версий.

А вот весь исходный код, который пишется непосредственно самим разработчиком находится в каталоге `usr`. Поэтому мы должны зайти туда и просмотреть находящиеся там файлы чтобы понять как сделаны компоненты и функции которые мы использовали на диаграммах и страницах.

#### Компонент FormContainer

Так как мы начинали урок с создания страницы, на которую поместили первым компонент `FormContainer`, давайте рассмотрим код этого компонента.

Откройте в любимом редакторе `src/usr/greeting/FormContainer.js` файл.

```javascript

import React from 'react';
import PropTypes from 'prop-types';
import { Placeholder } from "./Commons";

const rootStyle = {
  height: '450px',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
  width: '100%',
  overflow: 'auto',
};

const cellStyle = {
  padding: '5px 0'
};

/*
  Component holds a single form and a title
 */
const FormContainer = ({form, title}) => {
    return (
      <div style={rootStyle}>
        <div style={cellStyle}>
          {title}
        </div>
        <div style={cellStyle}>
          {form}
        </div>
      </div>
    );
};

FormContainer.propTypes = {
  // form element position
  form: PropTypes.element,
  // title element position
  title: PropTypes.element,
};

FormContainer.defaultProps = {
  form: <Placeholder name="form" />,
  title: <Placeholder name="title" />,
};

export default FormContainer;

```

**Как вы видите `FormContainer` - это функциональный компонент с названием полностью совпадающим с названием файла, и экспортируется он по умолчанию. Это есть первое условие того чтобы Webcodesk распознал в этом файле компонент и включил его в список доступных компонентов на левой панели в разделе `Components`.**

Также нас интересует почему при появлении в редакторе страниц компонент имеет еще два поля, в которые можно вставить другие компоненты.

Причиной этого является то, что в коде компонента есть определение свойств `form` и `title` с помощью PropTypes. И при этом тип этих свойств это `PropTypes.element`.

```javascript
FormContainer.propTypes = {
  // form element position
  form: PropTypes.element,
  // title element position
  title: PropTypes.element,
};
```

Данное объявление показывает Webcodesk, что этот компонент принимает другие компоненты в виде свойств. Поэтому в редакторе страницы мы видели пустые области когда данные свойства были пустыми. И мы могли туда переместить другие компоненты.

Эти же области вы найдете на отображении структуры страницы.

***{IMAGE}***

#### Компонент TitlePanel

Следующий код, который мы рассмотрим, это код компонента `TitlePanel` в файле `src/usr/greeting/TitlePanel.js`.

```javascript
import React from 'react';
import PropTypes from 'prop-types';
/*
  Panel with title
 */
class TitlePanel extends React.Component {
  static propTypes = {
    // simple title text
    title: PropTypes.string,
  };

  render () {
    const { title } = this.props;
    return (
      <h1 style={{ textAlign: 'center' }}>
        {title || 'Empty Title'}
      </h1>
    );
  }
}

export default TitlePanel;
```

**Второе правило объявления компонентов - это класс наследуемый от React.Component с названием полностью совпадающим с названием файла, и экспортом этого класаа по умолчанию.**

В этом компоненте также объявлено свойство с помощью PropTypes для того, чтобы Webcodesk мог использовать его как точку входа на диаграммах. Свойство имеет тип `PropTypes.string`.

#### Компонент Form

Для того чтобы увидеть как отображаются свойства событий на диаграмме, рассмотрим код компонента Form в файле `src/usr/greeting/Form.js`.

```javascript
import React from 'react';
import PropTypes from 'prop-types';

const rootStyle = {
  width: '150px',
  height: '150px',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
};

const inputStyle = {
  padding: '5px',
  borderRadius: '4px',
  border: '1px solid #cccccc',
};

const buttonStyle = {
  padding: '5px',
  borderRadius: '4px',
};

/*
  Input form for the user name
 */
class Form extends React.Component {
  static propTypes = {
    // send the entered name
    onClick: PropTypes.func,
  };

  handleClick = (e) => {
    if (e) {
      e.stopPropagation();
      e.preventDefault();
    }
    this.props.onClick(this.inputElement.value);
  };

  render () {
    return (
      <form onSubmit={this.handleClick}>
        <div style={rootStyle}>
          <div style={{ margin: '1em 0 1em 0' }}>
            <input
              ref={me => this.inputElement = me}
              type="text"
              placeholder="Enter your name"
              style={inputStyle}
            />
          </div>
          <div>
            <button
              type="submit"
              onClick={this.handleClick}
              style={buttonStyle}
            >
              Click
            </button>
          </div>
        </div>
      </form>
    );
  }
}

export default Form;
```

И в данном коде можно видеть, что свойство `onClick` имеет тип `PropTypes.func`, поэтому оно будет отображаться на диаграмме справа как выход данных из элемента.

А еще можно увидеть, что метод вызывается по нажатию кнопки на форме и тогда передается строка введенная в поле ввода.

> ***Подсказка***: передача данных в диаграммах происходит только для первого аргумента метода, поэтому, если будет указан второй аргумент в методе он будет проигнорирован и не будет передан дальше по цепочке. Чтобы передавать много данных инкапсулируйте их в объект и передавайте его в первом аргументе метода: ` this.props.onClick({data1, data2}); `

#### Итог

Давайте суммируем то, что мы увидели в коде.

Очевидно, что для того, чтобы ваш компонент мог включать в себя другие компоненты на странице, необходимо в классе или функции компонента объявить свойства с типом `PropTypes.element`.

Чтобы компонент мог отдавать данные по какому-то событию на диаграмме, необходимо добавить в него свойство типа `PropTypes.func`.

А для того, чтобы компонент мог быть получателем данных на диаграмме, необходимо добавить в него свойства любого типа кроме `PropTypes.element` и `PropTypes.func`.


